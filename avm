#!/usr/bin/env bash

set -e

echo "DEBUG: Starting AVM script execution"
echo "DEBUG: Script arguments: $@"
echo "DEBUG: Environment check:"
echo "DEBUG: - PWD: $(pwd)"
echo "DEBUG: - USER: ${USER:-<not set>}"
echo "DEBUG: - HOME: ${HOME:-<not set>}"
echo "DEBUG: - Shell: $0"

usage () {
  echo "Usage: avm <make target>"
}

# We need to do this because bash doesn't like it when a script is updated in place.
if [ -z ${AVM_SCRIPT_FORKED} ]; then
  # If AVM_SCRIPT_FORKED is not set, we are running the script from the original repository
  # Set AVM_SCRIPT_FORKED to true to avoid running this block again
  export AVM_SCRIPT_FORKED=true

  # Make a copy of this script in the current directory
  # and run that copy.
  cp "$0" .avm
  chmod +x .avm
  exec ./.avm "$@"
fi

# Default values for environment variables
CONTAINER_RUNTIME=${CONTAINER_RUNTIME:-"docker"}
CONTAINER_IMAGE=${CONTAINER_IMAGE:-"mcr.microsoft.com/azterraform:avm-latest"}
CONTAINER_PULL_POLICY=${CONTAINER_PULL_POLICY:-"always"}
AVM_MAKEFILE_REF=${AVM_MAKEFILE_REF:-"main"}
AVM_PORCH_REF=${AVM_PORCH_REF:-"main"}

if [ ! "$(command -v "${CONTAINER_RUNTIME}")" ] && [ -z "${AVM_IN_CONTAINER}" ]; then
    echo "Error: ${CONTAINER_RUNTIME} is not installed. Please install ${CONTAINER_RUNTIME} first."
    exit 1
fi

if [ -z "$1" ]; then
    echo "Error: Please provide a make target. See https://github.com/Azure/avm-terraform-governance/blob/main/Makefile for available targets."
    echo
    usage
    exit 1
fi

# Check if AZURE_CONFIG_DIR is set, if not, set it to ~/.azure
if [ -z "${AZURE_CONFIG_DIR}" ]; then
  AZURE_CONFIG_DIR="${HOME}/.azure"
fi

# Check if AZURE_CONFIG_DIR exists, if it does, mount it to the container
if [ -d "${AZURE_CONFIG_DIR}" ]; then
  AZURE_CONFIG_MOUNT="-v ${AZURE_CONFIG_DIR}:/home/runtimeuser/.azure"
fi

# If the host Docker socket exists, mount it into the container so the container can talk to the host docker daemon
echo "DEBUG: Checking Docker socket availability..."
echo "DEBUG: Docker socket path: /var/run/docker.sock"
if [ -e /var/run/docker.sock ]; then
  echo "DEBUG: Docker socket file exists"
  ls -la /var/run/docker.sock
  if [ -S /var/run/docker.sock ]; then
    echo "DEBUG: Docker socket is a socket file"
  else
    echo "DEBUG: Docker socket exists but is not a socket file"
  fi
  if [ -r /var/run/docker.sock ]; then
    echo "DEBUG: Docker socket is readable"
  else
    echo "DEBUG: Docker socket is not readable"
  fi
  if [ -w /var/run/docker.sock ]; then
    echo "DEBUG: Docker socket is writable"
  else
    echo "DEBUG: Docker socket is not writable"
  fi
else
  echo "DEBUG: Docker socket does not exist at /var/run/docker.sock"
fi

# Test Docker daemon connectivity
echo "DEBUG: Testing Docker daemon connectivity..."
if command -v docker >/dev/null 2>&1; then
  echo "DEBUG: Docker command is available"
  if docker version >/dev/null 2>&1; then
    echo "DEBUG: Docker daemon is accessible via docker command"
  else
    echo "DEBUG: Docker daemon is NOT accessible via docker command"
    echo "DEBUG: Docker version error output:"
    docker version 2>&1 || true
  fi

  # Test the _ping endpoint specifically
  echo "DEBUG: Testing Docker daemon _ping endpoint..."
  if docker system info >/dev/null 2>&1; then
    echo "DEBUG: Docker daemon _ping endpoint is accessible"
  else
    echo "DEBUG: Docker daemon _ping endpoint is NOT accessible"
    echo "DEBUG: Docker system info error output:"
    docker system info 2>&1 || true
  fi
else
  echo "DEBUG: Docker command is not available"
fi

# Set Docker socket mount based on detection
if [ -S /var/run/docker.sock ]; then
  DOCKER_SOCK_MOUNT="-v /var/run/docker.sock:/var/run/docker.sock"
  echo "DEBUG: Setting DOCKER_SOCK_MOUNT=$DOCKER_SOCK_MOUNT"
else
  DOCKER_SOCK_MOUNT=""
  echo "DEBUG: DOCKER_SOCK_MOUNT not set - socket test failed"
fi

# If we are in GitHub Copilot Coding Agent, we need to mount the SSL certificates from the host
SSL_CERT_MOUNTS=""
if [ -n "${COPILOT_AGENT_ACTION}" ]; then
  # Mount host's CA bundle to container's expected paths
  SSL_CERT_MOUNTS="${SSL_CERT_MOUNTS} -v /etc/ssl/certs/ca-certificates.crt:/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem:ro"
  SSL_CERT_MOUNTS="${SSL_CERT_MOUNTS} -v /etc/ssl/certs/ca-certificates.crt:/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt:ro"
fi

# New: allow overriding TUI behavior with PORCH_FORCE_TUI and PORCH_NO_TUI environment variables.
# - If PORCH_FORCE_TUI is set, force TUI and interactive mode (even in GH Actions).
# - If PORCH_NO_TUI is set, explicitly disable TUI.
# - Otherwise, fallback to previous behavior: enable TUI only when not in GitHub Actions and NO_COLOR is not set.
if [ -n "${PORCH_FORCE_TUI}" ]; then
  TUI="--tui"
  DOCKER_INTERACTIVE="-it"
  export FORCE_COLOR=1
elif [ -n "${PORCH_NO_TUI}" ]; then
  # Explicitly disable TUI and interactive flags
  TUI=""
  DOCKER_INTERACTIVE=""
else
  # If we are not in GitHub Actions and NO_COLOR is not set, we want to use TUI and interactive mode
  if [ -z "${GITHUB_RUN_ID}" ] && [ -z "${NO_COLOR}" ]; then
    TUI="--tui"
    DOCKER_INTERACTIVE="-it"
    export FORCE_COLOR=1
  fi
fi

# if AVM_PORCH_BASE_URL is set, we want to add it to the make command
if [ -n "${AVM_PORCH_BASE_URL}" ]; then
  PORCH_BASE_URL_MAKE_ADD="PORCH_BASE_URL=${AVM_PORCH_BASE_URL}"
fi

# Check if we are running in a container
# If we are then just run make directly
echo "DEBUG: Checking AVM_IN_CONTAINER environment variable..."
echo "DEBUG: AVM_IN_CONTAINER value: '${AVM_IN_CONTAINER:-<not set>}'"
echo "DEBUG: Current environment context:"
echo "DEBUG: - GITHUB_RUN_ID: '${GITHUB_RUN_ID:-<not set>}'"
echo "DEBUG: - CI: '${CI:-<not set>}'"
echo "DEBUG: - CONTAINER_RUNTIME: '$CONTAINER_RUNTIME'"
echo "DEBUG: - CONTAINER_IMAGE: '$CONTAINER_IMAGE'"

if [ -z "${AVM_IN_CONTAINER}" ]; then
  echo "DEBUG: Running in container mode - will execute docker run"
  echo "DEBUG: Container run parameters:"
  echo "DEBUG: - DOCKER_INTERACTIVE: '${DOCKER_INTERACTIVE:-<not set>}'"
  echo "DEBUG: - AZURE_CONFIG_MOUNT: '${AZURE_CONFIG_MOUNT:-<not set>}'"
  echo "DEBUG: - DOCKER_SOCK_MOUNT: '${DOCKER_SOCK_MOUNT:-<not set>}'"
  echo "DEBUG: - SSL_CERT_MOUNTS: '${SSL_CERT_MOUNTS:-<not set>}'"
  echo "DEBUG: Final docker run command will include docker socket mount: '${DOCKER_SOCK_MOUNT:-<NONE>}'"

  ${CONTAINER_RUNTIME} run \
    --pull "${CONTAINER_PULL_POLICY}" \
    --user "$(id -u):$(id -g)" \
    --rm \
    ${DOCKER_INTERACTIVE} \
    -v "$(pwd)":/src \
    ${AZURE_CONFIG_MOUNT:-} \
    ${DOCKER_SOCK_MOUNT:-} \
    ${SSL_CERT_MOUNTS:-} \
    -e ARM_CLIENT_ID \
    -e ARM_OIDC_REQUEST_TOKEN \
    -e ARM_OIDC_REQUEST_URL \
    -e ARM_SUBSCRIPTION_ID \
    -e ARM_TENANT_ID \
    -e ARM_USE_OIDC \
    -e FORCE_COLOR \
    -e GITHUB_TOKEN \
    -e NO_COLOR \
    -e PORCH_LOG_LEVEL \
    -e TF_IN_AUTOMATION=1 \
    --env-file <(env | grep '^TF_VAR_') \
    --env-file <(env | grep '^AVM_') \
    "${CONTAINER_IMAGE}" \
    make \
    TUI="${TUI}" \
    AVM_MAKEFILE_REF="${AVM_MAKEFILE_REF}" \
    "${PORCH_BASE_URL_MAKE_ADD}" \
    AVM_PORCH_REF="${AVM_PORCH_REF}" \
    "$1"
else
  echo "DEBUG: Running in direct mode - will execute make directly (AVM_IN_CONTAINER is set)"
  echo "DEBUG: Direct execution context:"
  echo "DEBUG: - Current user: $(id)"
  echo "DEBUG: - Current working directory: $(pwd)"
  echo "DEBUG: - Available Docker access:"
  if [ -e /var/run/docker.sock ]; then
    echo "DEBUG:   - Docker socket exists at /var/run/docker.sock"
    ls -la /var/run/docker.sock
  else
    echo "DEBUG:   - Docker socket does not exist at /var/run/docker.sock"
  fi
  if command -v docker >/dev/null 2>&1; then
    echo "DEBUG:   - Docker command available"
    if docker version >/dev/null 2>&1; then
      echo "DEBUG:   - Docker daemon accessible"
    else
      echo "DEBUG:   - Docker daemon NOT accessible"
    fi
  else
    echo "DEBUG:   - Docker command not available"
  fi

  make TUI="${TUI}" AVM_MAKEFILE_REF="${AVM_MAKEFILE_REF}" ${PORCH_BASE_URL_MAKE_ADD} AVM_PORCH_REF="${AVM_PORCH_REF}" "$1"
fi
